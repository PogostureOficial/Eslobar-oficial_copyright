<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Chat con IA</title>
  <link rel="stylesheet" href="index.css">
</head>
<body>
  <div id="titulo">¬øEn qu√© puedo ayudarte hoy?</div>

  <div id="chat" class="chat-box"></div>

  <div class="input-container">
    <textarea id="mensaje" rows="1" placeholder="Pregunta lo que quieras..." onkeydown="if(event.key==='Enter' && !event.shiftKey){event.preventDefault();enviarMensaje()}"></textarea>
    <div class="voice-btn" id="voiceBtn" aria-hidden="true">
      <img src="button1.png" id="btn1" class="initial-visible" alt="button1">
      <img src="button2.png" id="btn2" class="initial-hidden" alt="button2">
    </div>
  </div>

  <script>
    const input = document.getElementById('mensaje');
    const btn1 = document.getElementById('btn1'); // mic (initial)
    const btn2 = document.getElementById('btn2'); // send (appears when text)

    let isBtn2Visible = false;
    let animBtn1 = null;
    let animBtn2 = null;
    let animationTimeout; // <- nueva variable global
    let previousHasText = false;

    const D = 250; // duraci√≥n en ms por animaci√≥n
    const easing = 'cubic-bezier(.22,1,.36,1)';

function typeWriterEffect(container, text = '', speed = 15) {
  return new Promise((resolve) => {
    if (!text) { resolve(); return; }

    // Usamos parseBold para convertir *texto* en <b>texto</b>
    const parsed = parseBold(text);
    let i = 0;
    let buffer = "";

    const interval = setInterval(() => {
      buffer = parsed.slice(0, i + 1);
      container.innerHTML = buffer; // üëà ahora s√≠ interpreta etiquetas
      i++;

      if (container.parentElement) {
        container.parentElement.scrollTop = container.parentElement.scrollHeight;
      }

      if (i >= parsed.length) {
        clearInterval(interval);
        resolve();
      }
    }, speed);
  });
}


// ===== Agrega esto justo despu√©s de typeWriterEffect =====
function parseBold(text) {
  return text.replace(/\*(.*?)\*/g, '<b>$1</b>');
}

function addBotMessage() {
  const chat = document.getElementById("chat"); // tu contenedor
  const botMsg = document.createElement("div");
  botMsg.className = "message bot";
  chat.appendChild(botMsg);
  return botMsg;
}


    // Asegurar estados iniciales (por si acaso)
    btn1.style.visibility = 'visible';
    btn1.style.transform = 'scale(1)';
    btn1.style.opacity = '1';
    btn2.style.visibility = 'hidden';
    btn2.style.transform = 'scale(0)';
    btn2.style.opacity = '0';
    btn1.style.transformOrigin = 'center center';
    btn2.style.transformOrigin = 'center center';

    // Cancela animaciones en curso y 'congela' el estado actual en estilos inline
    function cancelAnimsAndFreeze() {
      if (animBtn1) {
        animBtn1.cancel();
        animBtn1 = null;
        const cs = getComputedStyle(btn1);
        btn1.style.transform = cs.transform === 'none' ? 'scale(1)' : cs.transform;
        btn1.style.opacity = cs.opacity;
      }
      if (animBtn2) {
        animBtn2.cancel();
        animBtn2 = null;
        const cs2 = getComputedStyle(btn2);
        btn2.style.transform = cs2.transform === 'none' ? 'scale(1)' : cs2.transform;
        btn2.style.opacity = cs2.opacity;
      }
    }

    function transitionToBtn2() {
      cancelAnimsAndFreeze();

      // Aseguramos que btn1 est√© visible para poder animarlo
      btn1.style.visibility = 'visible';

      // Shrink btn1
      animBtn1 = btn1.animate(
        [
          { transform: 'scale(1)', opacity: 1 },
          { transform: 'scale(0)', opacity: 0 }
        ],
        { duration: D, easing, fill: 'forwards' }
      );

      animBtn1.onfinish = () => {
        animBtn1 = null;
        // ocultamos btn1 al final
        btn1.style.visibility = 'hidden';
        btn1.style.transform = 'scale(0)';
        btn1.style.opacity = '0';

        // Hacemos aparecer btn2 (grow)
        btn2.style.visibility = 'visible';
        animBtn2 = btn2.animate(
          [
            { transform: 'scale(0)', opacity: 0 },
            { transform: 'scale(1)', opacity: 1 }
          ],
          { duration: D, easing, fill: 'forwards' }
        );

        animBtn2.onfinish = () => {
          animBtn2 = null;
          btn2.style.transform = 'scale(1)';
          btn2.style.opacity = '1';
          isBtn2Visible = true;

          // üîë Forzar correcci√≥n
          animationTimeout = setTimeout(() => {
            if (input.value.trim() === '') {
              transitionToBtn1();
            }
          }, 10);
        };
      };
    }

    function transitionToBtn1() {
      cancelAnimsAndFreeze();

      // Aseguramos que btn2 est√© visible para poder animarlo
      btn2.style.visibility = 'visible';

      // Shrink btn2
      animBtn2 = btn2.animate(
        [
          { transform: 'scale(1)', opacity: 1 },
          { transform: 'scale(0)', opacity: 0 }
        ],
        { duration: D, easing, fill: 'forwards' }
      );

      animBtn2.onfinish = () => {
        animBtn2 = null;
        // ocultamos btn2 al final
        btn2.style.visibility = 'hidden';
        btn2.style.transform = 'scale(0)';
        btn2.style.opacity = '0';

        // Hacemos aparecer btn1 (grow)
        btn1.style.visibility = 'visible';
        animBtn1 = btn1.animate(
          [
            { transform: 'scale(0)', opacity: 0 },
            { transform: 'scale(1)', opacity: 1 }
          ],
          { duration: D, easing, fill: 'forwards' }
        );

        animBtn1.onfinish = () => {
          animBtn1 = null;
          btn1.style.transform = 'scale(1)';
          btn1.style.opacity = '1';
          isBtn2Visible = false;

          // üîë Forzar correcci√≥n
          animationTimeout = setTimeout(() => {
            if (input.value.trim() !== '') {
              transitionToBtn2();
            }
          }, 10);
        };
      };
    }

    // Handler principal: decide transiciones solo si el estado deber√≠a cambiar
   input.addEventListener('input', () => {
  const hasText = input.value.trim() !== '';

  // Solo hacemos la transici√≥n si hubo un cambio real de estado
  if (hasText && !previousHasText) {
    // Primer car√°cter ingresado
    transitionToBtn2();
  } else if (!hasText && previousHasText) {
    // √öltimo car√°cter borrado
    transitionToBtn1();
  }

  // Actualizamos el estado previo
  previousHasText = hasText;
});


    /* ===== El resto de tu JS (enviarMensaje) queda igual ===== */
    async function enviarMensaje() {
      const chat = document.getElementById("chat");
      const titulo = document.getElementById("titulo");

      const userText = input.value.trim();
      if (!userText) return;

      // Ocultar t√≠tulo inicial
      titulo.style.opacity = 0;

      // Mensaje del usuario
      const userMsg = document.createElement("div");
      userMsg.className = "message user";
      userMsg.innerHTML = parseBold(userText);
      chat.appendChild(userMsg);

      input.value = ""; // ya estaba
      input.style.height = "auto"; // reset al tama√±o original


// Forzamos volver al bot√≥n de voz
if (previousHasText) {
  transitionToBtn1();
  previousHasText = false;
}


// Mostrar "Escribiendo..." con animaci√≥n de video
const loadingMsg = document.createElement("div");
loadingMsg.className = "message bot loading";
loadingMsg.innerHTML = `
  <span></span>
  <video src="anim1.mp4" autoplay loop muted playsinline width="40"></video>
`;
chat.appendChild(loadingMsg);
chat.scrollTop = chat.scrollHeight;


     try {
  // timeout + fetch robusto
  const controller = new AbortController();
  const timeoutMs = 10000; // 15s timeout
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

  const response = await fetch("http://localhost:3000/chat", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ message: userText }),
    signal: controller.signal
  });

  clearTimeout(timeoutId);

  // Si el servidor devuelve un status de error, lee el body para debug y muestra mensaje animado
  if (!response.ok) {
    console.error('Fetch HTTP error:', response.status, response.statusText);
    let bodyText = '';
    try { bodyText = await response.text(); } catch (e) { /* ignore */ }

    if (chat.contains(loadingMsg)) chat.removeChild(loadingMsg);

    const botMsg = addBotMessage();
    await typeWriterEffect(botMsg, `Error del servidor (${response.status}): ${response.statusText}`, 15);
    console.log('Server body (debug):', bodyText);
    return;
  }

  // Intentar parsear JSON de forma segura
  let data;
  try {
    data = await response.json();
  } catch (e) {
    console.error('JSON parse error:', e);
    if (chat.contains(loadingMsg)) chat.removeChild(loadingMsg);
    const botMsg = addBotMessage();
    await typeWriterEffect(botMsg, 'Respuesta inv√°lida del servidor.', 15);
    return;
  }

  // quitar "Escribiendo..."
  if (chat.contains(loadingMsg)) chat.removeChild(loadingMsg);

// RESET con animaci√≥n suave
const textarea = document.getElementById("mensaje");
textarea.value = "";
textarea.style.height = "auto";         // colapsa
requestAnimationFrame(() => {
  textarea.style.height = textarea.scrollHeight + "px"; // ajusta suavemente
});


  // Mostrar la respuesta (animada)
  const reply = (data && data.reply) ? parseBold(String(data.reply)) : 'No hay respuesta del servidor.';
  const botMsg = addBotMessage();
  await typeWriterEffect(botMsg, reply, 15);

} catch (error) {
  // cualquier fallo de red / timeout / abort aqu√≠
  if (chat.contains(loadingMsg)) chat.removeChild(loadingMsg);
  console.error('Fetch failed:', error);

  const botMsg = addBotMessage();
  // Mensaje √∫til para el usuario y hint para debug (cambia si quer√©s)
  const msg = (error.name === 'AbortError')
    ? 'La petici√≥n tard√≥ demasiado y fue cancelada.'
    : 'Lorem ipsum dolor sit amet üòÑ, consectetur adipiscing elit üöÄ. *Sed do eiusmod tempor incididunt* ut **labore et dolore magna aliqua.** üíª Ut enim ad minim veniam ‚ú®, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. üåç Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.';
  await typeWriterEffect(botMsg, msg, 10);
}
    }

    
    const textarea = document.getElementById("mensaje");

textarea.addEventListener("input", () => {
  textarea.style.height = "auto";
  textarea.style.height = textarea.scrollHeight + "px";
});


  </script>
</body>
</html>

